<html>
<head>
<title>CubeSat simulation</title>
<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
<style>
    body { margin: 0; }
    canvas { width: 100%; height: 100% }
</style>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
</head>
<body>
<div style="position:fixed; text-align: right; top:1%; right:0.5%; padding: 10px">
    <button class="btn btn-inverse" onclick="toggleEarth();">Toggle Earth</button>
    <button class="btn btn-inverse" onclick="toggleISS();">Toggle ISS</button>
    <button class="btn btn-inverse" onclick="toggleAxes();">Toggle axes</button>
    <br>
    <button class="btn btn-success" onclick="goForward();" style="margin-top: 5px;">Go forward</button>
    <button class="btn btn-danger" onclick="goBackward();" style="margin-top: 5px; margin-right: 5px;">Stop or go backward</button>
</div>
<script>
// Initialize scene and renderer
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.0001, 1000000 );
var renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
camera.position.z = 5;

// Browser camera controls
controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enableDamping = true;
controls.dampingFactor = 0.25;
controls.enableZoom = true;
controls.maxDistance = 500;

var ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);
var pointLight = new THREE.PointLight( 0xffffff );
pointLight.position.set( 0, 100, 0 );
scene.add(pointLight)

// Add axes
sceneAxes = buildAxes( 100 );
scene.add( sceneAxes );

// Add starfield, Earth, and ISS
addStarfield(scene);
addEarth(scene);
addClouds(scene);
addISS(scene);

// Add cube
var cube = buildCube();
scene.add( cube );

// Add thruster cones
var cones = buildThrusterCones();
for (i in cones)
{
    scene.add( cones[i] );
    cones[i].visible=false;
}

var iter = 0;
var forward = false;
var backward = false;
var threshold = 100;
var minThrust = 1/threshold;
var slowness = 50;
var coords = ["x", "y", "z"];
var momentum = new THREE.Vector3(0,0,0);

var render = function()
{
    requestAnimationFrame( render );

    if (forward || backward)
    {
        direction = getLookAtVector(controls);
        if (backward) { for (i in coords) direction[coords[i]] *= -1; }
        if (iter < threshold)
        {
            for (i in coords) {
                if (Math.abs(direction[coords[i]]) > minThrust)
                {
                    interval = Math.round(1/direction[coords[i]]);
                    coneName = (direction[coords[i]] < 0 ? "-" : "") + coords[i];
                    // Naive thruster flashing - bad for direction_i equiv 1
                    if (iter%interval == 0) cones[coneName].visible = true;
                    else cones[coneName].visible = false;
                    // Move cubes and cone - bad if view direction changes
                    camera.position[coords[i]] += direction[coords[i]]/slowness;
                    cube.position[coords[i]] += direction[coords[i]]/slowness;
                    for (c in cones) cones[c].position[coords[i]] += direction[coords[i]]/slowness;
                }
            }
            iter += 1;
        }
        else if (iter >= threshold)
        {
            iter = 0;
            forward = backward = false;
            // Turn off all thrusters
            for (c in cones) cones[c].visible = false;
            // Set momentum vector resulting from thrust
            for (i in coords) momentum[coords[i]] += direction[coords[i]]/slowness;
        }
    }

    // Move ensemble
    for (i in coords)
    {
        camera.position[coords[i]] += momentum[coords[i]];
        cube.position[coords[i]] += momentum[coords[i]];
        for (c in cones)
            cones[c].position[coords[i]] += momentum[coords[i]];
    }
    controls.target = cube.position;

    earth.rotation.x += .00006;
    clouds.rotation.x += .000035;

    renderer.render(scene, camera);
};

render();

// Button-invoked functions

function goForward()
{
    forward = true;
}

function goBackward()
{
    backward = true;
}

function toggleAxes()
{
    sceneAxes.visible = !sceneAxes.visible;
}

function toggleEarth()
{
    earth.visible = !earth.visible;
    clouds.visible = !clouds.visible;
}

function toggleISS()
{
    ISS.visible = !ISS.visible;
}

// Internal functions

function getLookAtVector(controls)
{
    var phi = controls.getAzimuthalAngle();
    var theta = controls.getPolarAngle();
    return new THREE.Vector3(-Math.sin(theta)*Math.sin(phi), -Math.cos(theta), -Math.sin(theta)*Math.cos(phi));
}

function buildCube()
{
    var cubeSide = .5;
    var geometry = new THREE.BoxGeometry( cubeSide, cubeSide, cubeSide );
    for ( var i = 0; i < geometry.faces.length; i ++ ) {
        geometry.faces[ i ].color.setHex( Math.random() * 0xffffff );
    }
    var material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
    return new THREE.Mesh( geometry, material );
}

function buildThrusterCones()
{
    var coneHeight = .75;
    var coneBase = .15;
    var coneMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
    var coneGeometry = new THREE.CylinderGeometry(0, coneBase, coneHeight, 4, 1, false);
    coneGeometry.translate( 0, -coneHeight/2, 0 ); // make tip pivot
    var cones = {};
    cones["y"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["-y"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["-y"].rotation.z = Math.PI;
    cones["x"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["x"].rotation.z = -Math.PI/2
    cones["-x"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["-x"].rotation.z = Math.PI/2;
    cones["z"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["z"].rotation.z = Math.PI/2;
    cones["z"].rotation.y = Math.PI/2;
    cones["-z"] = new THREE.Mesh( coneGeometry, coneMaterial );
    cones["-z"].rotation.z = Math.PI/2;
    cones["-z"].rotation.y = -Math.PI/2;
    return cones;
}

function addISS(scene)
{
    // Honestly just roll your own at some point, basic outline is easy
    var loader = new THREE.JSONLoader();
    loader.load('partOfISS.json', function (geometry, materials)
    {
      var material = new THREE.MeshPhongMaterial({color: 0xcccccc});
      var ISS = new THREE.Mesh( geometry, material );
      ISS.rotation.y -= Math.PI/2;
      ISS.scale.set(.03,.03,.03);
      ISS.position.z -= 10;
      scene.add(ISS);
    });
}

function addClouds(scene)
{
    var earthRadius = 6367445;
    var ISSheight = 400727;
    var cloudHeight = 11278;
    var cloudSphere  = new THREE.SphereGeometry(earthRadius+cloudHeight, 100, 100);
    var loader = new THREE.TextureLoader();
    loader.load(
        // resource URL
        'clouds.png',
        // Function called when resource is loaded
        function ( texture )
        {
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipMapLinearFilter;
            var cloudMaterial = new THREE.MeshBasicMaterial( {
              map         : texture,
              side        : THREE.FrontSide,
              opacity     : 0.8,
              transparent : true,
              depthWrite  : false,
            } );
            clouds = new THREE.Mesh(cloudSphere, cloudMaterial);
            clouds.position.y = -(earthRadius + ISSheight);
            clouds.rotation.z = Math.PI/2;
            clouds.rotation.x += Math.PI/2;
            scene.add(clouds);
        },
        // Function called when download progresses
        function ( xhr )
        {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
        },
        // Function called when download errors
        function ( xhr )
        {
            console.log( 'Error loading Earth texture.' );
        }
    );
}

function addEarth(scene)
{
    var earthRadius = 6367445;
    var ISSheight = 400727;
    var earthSphere  = new THREE.SphereGeometry(earthRadius, 100, 100);
    var loader = new THREE.TextureLoader();
    loader.load(
        // resource URL
        'earth.jpg',
        // Function called when resource is loaded
        function ( texture )
        {
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipMapLinearFilter;
            var earthMaterial = new THREE.MeshBasicMaterial( { map: texture } );
            earth = new THREE.Mesh(earthSphere, earthMaterial);
            earth.position.y = -(earthRadius + ISSheight);
            earth.rotation.z = Math.PI/2;
            scene.add(earth);
        },
        // Function called when download progresses
        function ( xhr )
        {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
        },
        // Function called when download errors
        function ( xhr )
        {
            console.log( 'Error loading Earth texture.' );
        }
    );
}

function addStarfield(scene)
{
    // create the geometry sphere
    var backgroundSphere  = new THREE.SphereGeometry(100000, 60, 60);
    // create the material, using a texture of startfield
    var loader = new THREE.TextureLoader();
    loader.load(
        // resource URL
        'starfield.jpg',
        // Function called when resource is loaded
        function ( texture )
        {
            var backgroundMaterial = new THREE.MeshBasicMaterial( {
                map: texture,
                side: THREE.BackSide } );
              // backgroundMaterial.map.wrapS = THREE.RepeatWrapping;
              // backgroundMaterial.map.wrapT = THREE.RepeatWrapping;
              // backgroundMaterial.map.repeat.set( 5, 3);
            var background  = new THREE.Mesh(backgroundSphere, backgroundMaterial);
            scene.add(background);
        },
        // Function called when download progresses
        function ( xhr ) {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
        },
        // Function called when download errors
        function ( xhr ) {
            console.log( 'Error loading space texture.' );
        }
    );
}

function buildAxes( length )
{
    var axes = new THREE.Object3D();
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z
    return axes;
}

function buildAxis( src, dst, colorHex, dashed )
{
    var geom = new THREE.Geometry(),
        mat;
    if(dashed) {
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    } else {
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
    }
    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines
    var axis = new THREE.Line( geom, mat, THREE.LineSegments );
    return axis;

}
</script>
</body>
</html>
